#include <LiquidCrystal.h>

LiquidCrystal lcd(2, 3, 4, 5, 6, 7);

int analogPin = A0;
int botonInicio = 8;  // Botón para iniciar 
int botonDetener = 13;  // Botón para detener

int val = 0;
bool adquiriendo = false;

int valorMax = 511;  // Punto 
int valorMin = 511;  // Punto medio
float amplitudVoltios = 0;  // Variable para almacenar la amplitud
const int offset = 511; 

unsigned long tiempoUltimoCambio = 0;
const unsigned long debounceDelay = 200;

int cruces = 0;  // Contador de cruces
int estadoAnterior = 511;  
unsigned long tiempoInicio = 0;  
unsigned long duracion = 0;  // tiempo
float frecuenciaHz = 0;  

void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);

  pinMode(botonInicio, INPUT_PULLUP);  
  pinMode(botonDetener, INPUT_PULLUP);  

  lcd.print("Esperando...");
}

void loop() {
  unsigned long tiempoActual = millis();

  //  botón de inicio
  if (digitalRead(botonInicio) == LOW && (tiempoActual - tiempoUltimoCambio > debounceDelay)) {
    adquiriendo = true;  // Cambia el estado a adquiriendo
    lcd.clear();
    lcd.print("Adquiriendo...");
    valorMax = offset;  
    valorMin = offset;  
    cruces = 0;  // Reiniciar el contador
    estadoAnterior = analogRead(analogPin);  // Estado inicial de la señal
    tiempoInicio = millis();  // Registra el tiempo de inicio
    tiempoUltimoCambio = tiempoActual;
  }

  //  botón de detener
  if (digitalRead(botonDetener) == LOW && (tiempoActual - tiempoUltimoCambio > debounceDelay)) {
    adquiriendo = false;  
    lcd.clear();
    lcd.print("Detenido...");

    // Calcula la amplitud en voltios
    amplitudVoltios = (valorMax - valorMin) * (5.0 / 1023.0);

    // Calcula la duración de la toma de muestra
    duracion = millis() - tiempoInicio;  // Duración
    if (duracion > 0) {
      frecuenciaHz = (cruces / 2.0) / (duracion / 1000.0);  // Cruces 
    }

    // Mostrar la amplitud y la frecuencia en el Serial Monitor
    Serial.print("Amplitud pico a pico: ");
    Serial.print(amplitudVoltios);
    Serial.println(" V");
#include <LiquidCrystal.h>

LiquidCrystal lcd(2, 3, 4, 5, 6, 7);

int analogPin = A0;
int botonInicio = 8;  // Botón para empezar
int botonDetener = 13;  // Botón para detener
int val = 0;
bool adquiriendo = false;

int valorMax = -1024;  // Valor máximo
int valorMin = 1024;   // Valor mínimo
int cruces = 0;  // Cruces por el valor medio
float frecuencia = 0;  // Frecuencia
float amplitudVoltios = 0;  // Amplitud en voltios
const int offset = 511;  // Valor de referencia (2.5V)

unsigned long tiempoInicio = 0;  // Tiempo inicial
unsigned long duracion = 0;  // Duración

int muestraAnterior = 0;  // Muestra anterior
bool enPico = false;  // Para verificar si hay un pico

// Identificar tipo de onda
bool esCuadrada = true;
bool esSenoidal = true;
bool esTriangular = true;

void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);

  pinMode(botonInicio, INPUT_PULLUP);
  pinMode(botonDetener, INPUT_PULLUP);

  lcd.print("Esperando...");
}

void loop() {
  unsigned long tiempoActual = millis();

  // Iniciar adquisición
  if (digitalRead(botonInicio) == LOW && !adquiriendo) {
    adquiriendo = true;
    valorMax = -1024;  // Reiniciar máximos y mínimos
    valorMin = 1024;
    cruces = 0;
    esCuadrada = true;  // Suponemos cuadrada al principio
    esSenoidal = true;  // Suponemos senoidal al principio
    esTriangular = true;  // Suponemos triangular al principio
    enPico = false;  // Reiniciar picos
    muestraAnterior = analogRead(analogPin);  // Tomar primera muestra
    tiempoInicio = millis();  // Guardar el tiempo
    lcd.clear();
    lcd.print("Leyendo...");
    Serial.println("Adquisición iniciada...");
  }

  // Detener adquisición
  if (digitalRead(botonDetener) == LOW && adquiriendo) {
    adquiriendo = false;
    duracion = millis() - tiempoInicio;  // Calcular duración

    // Calcular amplitud
    int amplitudPicoPico = valorMax - valorMin;
    amplitudVoltios = amplitudPicoPico * (5.0 / 1023.0);  // Convertir a voltios

    // Calcular frecuencia
    if (duracion > 0) {
      frecuencia = (cruces / 2.0) / (duracion / 1000.0);  // Frecuencia en Hz
    }

    // Mostrar resultados en Serial
    Serial.print("Amplitud: ");
    Serial.print(amplitudVoltios);
    Serial.println(" V");
    Serial.print("Frecuencia: ");
    Serial.print(frecuencia);
    Serial.println(" Hz");

    // Mostrar en la LCD
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Amp: ");
    lcd.print(amplitudVoltios);
    lcd.print(" V");
    lcd.setCursor(0, 1);
    lcd.print("Freq: ");
    lcd.print(frecuencia);
    lcd.print(" Hz");

    delay(1500);  // Pausa para mostrar

    // Mostrar tipo de onda
    lcd.clear();
    if (esCuadrada) {
      lcd.print("Onda: Cuadrada");
    } else if (esSenoidal) {
      lcd.print("Onda: Senoidal");
    } else if (esTriangular) {
      lcd.print("Onda: Triangular");
    } else {
      lcd.print("Onda: Desconocida");
    }

    Serial.println("Adquisición detenida.");
  }

  // Tomar lecturas si está adquiriendo
  if (adquiriendo) {
    int lectura = analogRead(analogPin);  // Leer valor

    // Actualizar máximos y mínimos
    if (lectura > valorMax) {
      valorMax = lectura;
    }
    if (lectura < valorMin) {
      valorMin = lectura;
    }

    // Contar cruces por el valor medio
    if ((lectura > offset && muestraAnterior <= offset) || (lectura < offset && muestraAnterior >= offset)) {
      cruces++;
    }

    // Detectar si no es cuadrada
    if (lectura != valorMax && lectura != valorMin) {
      esCuadrada = false;
    }

    // Detectar picos
    int pendienteActual = lectura - muestraAnterior;  // Pendiente entre muestras

    // Comprobar si estamos en un pico
    if ((pendienteActual < 0 && muestraAnterior > valorMax * 0.9) || 
        (pendienteActual > 0 && muestraAnterior < valorMin * 1.1)) {
      enPico = true;
    } else {
      enPico = false;
    }

    // Verificar si es triangular o senoidal
    if (enPico && abs(pendienteActual) < 10) {
      esTriangular = false;
    } else if (enPico && abs(pendienteActual) > 50) {
      esSenoidal = false;
    }

    muestraAnterior = lectura;  // Actualizar muestra anterior

    // Mostrar valor actual en el Monitor Serial
    Serial.println(lectura);

    delay(100);  // Pausa corta
  }
}
