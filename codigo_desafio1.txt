#include <LiquidCrystal.h>

LiquidCrystal lcd(2, 3, 4, 5, 6, 7);

int analogPin = A0;
int botonInicio = 8;  // Botón para iniciar la toma de muestras
int botonDetener = 13;  // Botón para detener la toma de muestras

int val = 0;
bool adquiriendo = false;

int valorMax = 511;  // Punto medio de referencia en 511 (2.5V)
int valorMin = 511;  // Punto medio de referencia en 511 (2.5V)
float amplitudVoltios = 0;  // Variable para almacenar la amplitud en voltios
const int offset = 511;  // Valor de referencia que corresponde a 2.5V

unsigned long tiempoUltimoCambio = 0;
const unsigned long debounceDelay = 200;

int cruces = 0;  // Contador de cruces
int estadoAnterior = 511;  // Para almacenar el estado anterior de la señal
unsigned long tiempoInicio = 0;  // Tiempo en que comenzó la adquisición
unsigned long duracion = 0;  // Duración de la adquisición
float frecuenciaHz = 0;  // Variable para almacenar la frecuencia en Hz

void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);

  pinMode(botonInicio, INPUT_PULLUP);  // Botón 1 con resistencia pull-up interna
  pinMode(botonDetener, INPUT_PULLUP);  // Botón 2 con resistencia pull-up interna

  lcd.print("Esperando...");
}

void loop() {
  unsigned long tiempoActual = millis();

  // Iniciar la adquisición con el botón de inicio
  if (digitalRead(botonInicio) == LOW && (tiempoActual - tiempoUltimoCambio > debounceDelay)) {
    adquiriendo = true;  // Cambia el estado a adquiriendo
    lcd.clear();
    lcd.print("Adquiriendo...");
    valorMax = offset;  // Reiniciar el valor máximo en el offset (2.5V)
    valorMin = offset;  // Reiniciar el valor mínimo en el offset (2.5V)
    cruces = 0;  // Reiniciar el contador de cruces
    estadoAnterior = analogRead(analogPin);  // Estado inicial de la señal
    tiempoInicio = millis();  // Registra el tiempo de inicio
    tiempoUltimoCambio = tiempoActual;
  }

  // Detener la adquisición con el botón de detener
  if (digitalRead(botonDetener) == LOW && (tiempoActual - tiempoUltimoCambio > debounceDelay)) {
    adquiriendo = false;  // Cambia el estado a detenido
    lcd.clear();
    lcd.print("Detenido...");

    // Calcular la amplitud en voltios
    amplitudVoltios = (valorMax - valorMin) * (5.0 / 1023.0);

    // Calcular la duración de la adquisición
    duracion = millis() - tiempoInicio;  // Duración en milisegundos
    if (duracion > 0) {
      frecuenciaHz = (cruces / 2.0) / (duracion / 1000.0);  // Cruces divididos por la duración en segundos
    }

    // Mostrar la amplitud y la frecuencia en el Serial Monitor
    Serial.print("Amplitud pico a pico: ");
    Serial.print(amplitudVoltios);
    Serial.println(" V");

    Serial.print("Frecuencia: ");
    Serial.print(frecuenciaHz);
    Serial.println(" Hz");

    // Mostrar la amplitud y frecuencia en la LCD
    lcd.setCursor(0, 0);
    lcd.print("Amp: ");
    lcd.print(amplitudVoltios);
    lcd.print(" V");
    lcd.setCursor(0, 1);
    lcd.print("Freq: ");
    lcd.print(frecuenciaHz);
    lcd.print(" Hz");

    tiempoUltimoCambio = tiempoActual;
  }

  // Si estamos adquiriendo, leer los valores del pin analógico
  if (adquiriendo) {
    int lectura = analogRead(analogPin);  // Leer el valor analógico

    // Actualizar el valor máximo y mínimo
    if (lectura > valorMax) {
      valorMax = lectura;
    }
    if (lectura < valorMin) {
      valorMin = lectura;
    }

    // Contar los cruces por el valor de referencia (offset)
    if ((lectura > offset && estadoAnterior <= offset) || (lectura < offset && estadoAnterior >= offset)) {
      cruces++;
    }
    estadoAnterior = lectura;  // Actualizar el estado anterior

    // Mostrar el valor actual en el Monitor Serial
    Serial.print("Valor actual: ");
    Serial.println(lectura);

    delayMicroseconds(10);  // Pausa para mejorar la simulación
  }
}
